'''
Observe that both ciphertexts c and c2 were encrypted using the same modulus n but different public exponents e and e2.
This makes the system vulnerable to the Common Modulus Attack, which allows us to recover the plaintext message m when e and e2 are coprime.
If gcd(e1, e2) = 1,
    then there exist integers a and b such that a*e + b*e2 = 1 (using the Extended Euclidean Algorithm).
    Thus, m can be computed as:
        m = (c^a * c2^b) mod n

To use Extended Euclidean Algorithm, we can use the gmpy2 library in Python.
To install gmpy2, you can use:
pip install gmpy2
OR
py -m pip install gmpy2
'''

from Crypto.Util.number import inverse, long_to_bytes, bytes_to_long
import gmpy2

# Common n
n = 28613370073421778967605514732870472849214603657316054493433566383953575567049700827092565638191112896372565114955037566029899716494193506767622661809959162166470274362104410044121619889335489995340438494554201044114882061630250004222565365449835830068052396270365356933873300339276625543610983257286490531284664598240634311690163372864322731519994639259777650975394179570756084811994252529139934469043253569508149257461832546650328860991132812956481499689759082721890198989123114141079195979384926401835656882388537312552038964313138454443736978796250004440250299863595915863790723901552456034764227220749349266470069

e = 131101
c=24995668846198777835141872786124186349626521573665538399423673848337519154738798371184485463819700749184141612886994267865767639471683780318954596761848933573585977559175043817607316696911716466599886472471742737736260096251550466788725402250919387117895304118627625484038698196657907015017181368195566338738848508669441804331017404963573716303441992780391432767830499931162431019360288986712121494901763723173928960297680835518331133900042813238479479889399317403243143959201604195604251356477898602106812646920758604092130386598232918438272512034782613241243723204571791594168917619787871982307587304918959560899528

e2 = 65537
c2=4895095798918450416967078462352884675800772599385907244595612276639709588959753995929046884740042453526390744295641417188367820623591624620016644535958152597908541791546213937667560477931535421866924176591694973789438771760216386527029222046715140722182515333857483995351747533416237038869577459691284119948035384267530824947077677437166857991306038935751371411824962413639209155943453838115200984982896122828958881247242676040030138381033239471138520642252557848400590882538485286607701527193983861621142888785861225524389442880519759254392468146193136671341582590885823078374613692824299147713349904082109806618883

gcd, a, b = gmpy2.gcdext(e, e2) # Extended Euclidean Algorithm
print(f"gcd: {gcd}, a: {a}, b: {b}")

if gcd == 1:
    print('Susceptible to Common Modulus Attack')

    first_product = pow(c, a, n)
    second_product = pow(c2, b, n)
    m = (first_product * second_product) % n
    msg = str(long_to_bytes(m))[2:-1].strip()
    print(msg)
else:
    print("e and e2 are not coprime; Common Modulus Attack not possible.")